using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using SchemaForge.Crucible.Extensions;
using SchemaForge.Crucible.Utilities;
using Newtonsoft.Json.Linq;

namespace SchemaForge.Crucible
{
  /// <summary>
  /// A <see cref="Field"/> represents a value that is expected to exist in a collection processed by a <see cref="Schema"/> object.
  /// <see cref="Field"/>s can have up to 3 types passed as type parameters, each a possible type of the corresponding value in the
  /// object to be analyzed by the Schema.
  /// </summary>
  public abstract class Field
  {
    /// <summary>
    /// Name of the <see cref="Field"/>; corresponds to a field present in the collectioni that will be validated.
    /// </summary>
    public string FieldName { get; protected set; }

    /// <summary>
    /// String that will be added to a <see cref="Schema.ErrorList"/> object as ErrorSeverity.Info when a validation error occurs for this <see cref="Field"/>.
    /// </summary>
    public string Description { get; protected set; }

    /// <summary>
    /// Contains all the errors generated by validation functions.
    /// </summary>
    public List<SchemaError> ErrorList { get; protected set; } = new List<SchemaError>();

    /// <summary>
    /// If false, null or empty <see cref="Field"/> values are fatal errors. If true, they are warnings instead.
    /// </summary>
    public bool AllowNull { get; protected set; } = false;

    /// <summary>
    /// Represents the constraints on the <see cref="Field"/> as a set of Json objects, one per possible type.
    /// </summary>
    public JArray JsonConstraint { get; protected set; } = new JArray();

    /// <summary>
    /// Indicates whether or not this <see cref="Field"/> is required.
    /// </summary>
    public bool Required { get; protected set; }

    /// <summary>
    /// If DefaultValue is set and the <see cref="Field"/> is optional, then if the user does not include this
    /// <see cref="Field"/> in their configuration file, the default value will be inserted with <see cref="FieldName"/> as the field name.
    /// </summary>
    public object DefaultValue { get; protected set; } = null;

    /// <summary>
    /// Converts a <see cref="Field"/> into a JProperty of format "<see cref="FieldName"/>":{ "Constraints":<see cref="JsonConstraint"/>, "Description":"<see cref="Description"/>" }
    /// </summary>
    /// <returns>JProperty of format "<see cref="FieldName"/>":{ "Constraints":<see cref="JsonConstraint"/>, "Description":"<see cref="Description"/>"</returns>
    public JProperty ToJProperty() => new JProperty(FieldName, new JObject() { { "Constraints", JsonConstraint.Count > 1 ? JsonConstraint : JsonConstraint[0] }, { "Description", Description } });

    /// <summary>
    /// Returns a new <see cref="Field"/> with an additional type and new constraints added. Used primarily during deserialization.
    /// </summary>
    /// <typeparam name="TNewType">New possible type to add to the <see cref="Field"/>.</typeparam>
    /// <param name="newConstraints">Constraints to apply if cast to the new type is successful.</param>
    /// <returns>New <see cref="Field"/> with all pre-existing types, plus <typeparamref name="TNewType"/></returns>
    public abstract Field AddNewType<TNewType>(Constraint<TNewType>[] newConstraints);

    /// <summary>
    /// Extracts a <see cref="Field"/> value from the given <paramref name="collection"/> using the 
    /// <see cref="ISchemaTranslator{TCollectionType}.TryCastValue{TCastType}(TCollectionType, string, out TCastType)"/>
    /// method, with <see cref="FieldName"/> as the passed string. All non-abstract
    /// <see cref="Field"/>s have a set of type parameters. The method above will attempt casts
    /// in the order those type parameters are provided; the first successful cast will
    /// result in the corresponding ConstraintsIfTypeN array being applied to the <see cref="Field"/> value.
    /// </summary>
    /// <typeparam name="TCollectionType">Collection from which the <see cref="Field"/> value will be
    /// extracted.</typeparam>
    /// <param name="collection">Collection to extract a value from.</param>
    /// <param name="translator">Translator object to use when interacting with
    /// the specified collection.</param>
    /// <returns>Bool indicating whether or not any fatal errors were
    /// raised by the constraint functions.</returns>
    public virtual bool Validate<TCollectionType>(TCollectionType collection, ISchemaTranslator<TCollectionType> translator)
    {
      if (translator.FieldValueIsNullOrEmpty(collection, FieldName))
      {
        ErrorList.Add(new SchemaError($"Value of field {FieldName} is null or empty.", AllowNull?Severity.Warning:Severity.Fatal));
      }
      return !ErrorList.AnyFatal();
    }

    /// <summary>
    /// Inserts this <see cref="Field"/>'s DefaultValue into <paramref name="collection"/> using the relevant method from <paramref name="translator"/>.
    /// </summary>
    /// <typeparam name="TCollectionType">Type of collection to perform the operation on.</typeparam>
    /// <param name="collection">Collection to insert the value into.</param>
    /// <param name="translator">Translator used to interpret <typeparamref name="TCollectionType"/></param>
    /// <returns>A new <typeparamref name="TCollectionType"/> <paramref name="collection"/> with the value added.</returns>
    public TCollectionType InsertDefaultValue<TCollectionType>(TCollectionType collection, ISchemaTranslator<TCollectionType> translator) => translator.InsertFieldValue(collection, FieldName, DefaultValue);

    #region Overrides

    /// <summary>
    /// Represents a <see cref="Field"/> as a string, returning <see cref="FieldName"/>.
    /// </summary>
    /// <returns><see cref="FieldName"/> of this <see cref="Field"/></returns>
    public override string ToString() => FieldName;

    /// <summary>
    /// All equality operators compare the <see cref="FieldName"/> of two <see cref="Field"/>s to determine equality.
    /// </summary>
    /// <param name="obj">The other object to compare.</param>
    /// <returns>Bool indicating if two <see cref="Field"/>s have the same name.</returns>
    public override bool Equals(object obj) => this.Equals(obj as Field);

    /// <summary>
    /// All equality operators compare the <see cref="FieldName"/> of two <see cref="Field"/>s to determine equality.
    /// </summary>
    /// <param name="other">The other <see cref="Field"/> to compare.</param>
    /// <returns>Bool indicating if two <see cref="Field"/>s have the same name.</returns>
    public bool Equals(Field other) => other.Exists() && this.FieldName == other.FieldName;

    /// <summary>
    /// Sets the HashCode of a <see cref="Field"/> to the HashCode of its <see cref="FieldName"/>.
    /// </summary>
    /// <returns>HashCode of <see cref="FieldName"/> string.</returns>
    public override int GetHashCode() => FieldName.GetHashCode();

    #endregion

    #region Helper Methods

    /// <summary>
    /// Gets JObject representation of the type and all other constraints.
    /// </summary>
    /// <typeparam name="TValueType">Type of all constraints.</typeparam>
    /// <param name="constraints">Array of constraints passed to the constructor.</param>
    /// <returns>JObject representation of the constraints applied to the <see cref="Field"/>.</returns>
    public static JObject GetConstraintObject<TValueType>(Constraint<TValueType>[] constraints)
    {
      JObject constraintObject = new JObject();
      try
      {
        if (Nullable.GetUnderlyingType(typeof(TValueType)) != null)
        {
          constraintObject.Add("Type", ShippingAndReceiving.TypeMap(typeof(TValueType).GenericTypeArguments[0].Name));
        }
        else
        {
          constraintObject.Add("Type", ShippingAndReceiving.TypeMap(typeof(TValueType).Name));
        }
      }
      catch
      {
        //throw new ArgumentException($"Attempted to pass unsupported type {typeof(TValueType).Name}\nSupported types: {ShippingAndReceiving.GetSupportedTypes().Join(", ")}\nIf needed, use AddSupportedType to add a new type to the recognized types. This will enable SchemaForge to recognize this field type for your project.");
      }
      if (constraints.Exists())
      {
        foreach (Constraint<TValueType> constraint in constraints)
        {
          if(constraint.Property.Exists())
          {
            constraintObject.Add(constraint.Property);
          }
        }
      }
      return constraintObject;
    }

    /// <summary>
    /// Sets all the non-generically typed values of a <see cref="Field"/>.
    /// </summary>
    /// <param name="inputName">Name to set.</param>
    /// <param name="inputDescription"><see cref="Description"/> to set.</param>
    /// <param name="required">Indicates if the <see cref="Field"/> is required.</param>
    /// <param name="allowNull">Indicates if Null should be permitted for the <see cref="Field"/>'s value.</param>
    protected void BuildFieldCore(string inputName, string inputDescription, bool required, bool allowNull)
    {
      if (inputName.IsNullOrEmpty())
      {
        throw new ArgumentNullException(nameof(inputName));
      }
      Required = required;
      FieldName = inputName;
      Description = inputDescription;
      AllowNull = allowNull;
    }

    /// <summary>
    /// Takes the castResult from a call to an ISchemaTranslator's
    /// TryCastValue function, then applies constraints if the cast
    /// succeeded or returns false if it did not.
    /// </summary>
    /// <typeparam name="TValueType">Type that the collection member was cast to.</typeparam>
    /// <param name="castResult"><see cref="Field"/> value cast to <typeparamref name="TValueType"/> using <see cref="ISchemaTranslator{TCollectionType}.TryCastValue{TCastType}(TCollectionType, string, out TCastType)"/>.</param>
    /// <param name="constraints">Constraints to apply.</param>
    protected void InternalValidate<TValueType>(TValueType castResult, List<Constraint<TValueType>> constraints)
    {
      if(constraints.Exists())
      {
        foreach (Constraint<TValueType> constraint in constraints)
        {
          ErrorList.AddRange(constraint.Function(castResult, FieldName));
        }
      }
    }

    /// <summary>
    /// Takes the castResult from a call to an ISchemaTranslator's
    /// TryCastValue function to string, then applies format constraints.
    /// </summary>
    /// <typeparam name="TValueType">Type that the collection member was originally cast to.</typeparam>
    /// <param name="castResult">Tuple that indicates whether the cast succeeded and contains the cast result.</param>
    /// <param name="constraints">Constraints to apply if cast succeeded.</param>
    protected void InternalValidateFormat<TValueType>(string castResult, List<Constraint<TValueType>> constraints)
    {
      if (constraints.Exists())
      {
        foreach (Constraint<TValueType> constraint in constraints)
        {
          ErrorList.AddRange(constraint.FormatFunction(castResult, FieldName));
        }
      }
    }

    /// <summary>
    /// Ensures that the <see cref="DefaultValue"/> can be cast to one of the types provided for the <see cref="Field"/>.
    /// </summary>
    /// <returns>Bool indicating if <see cref="DefaultValue"/> is valid.</returns>
    protected bool CheckDefaultValue()
    {
      Type[] typeArray = GetType().GetGenericArguments();
      Type defaultValueType = DefaultValue.GetType();
      foreach (Type currentType in typeArray)
      {
        if(currentType == typeof(DateTime)) // DateTime is a special case because of how many formats it can use.
        {
          return Conversions.TryConvertDateTime(DefaultValue.ToString(), out _);
        }
        else if (defaultValueType.IsAssignableFrom(currentType))
        {
          return true;
        }
      }
      return false;
    }

    #endregion
  }

  /// <summary>
  /// A <see cref="Field"/> represents a value that is expected to exist in a collection processed by a <see cref="Schema"/> object.
  /// All passed types must be unique.
  /// WARNING: Casts will be attempted IN ORDER. For example,
  /// Field{string, int} will NEVER treat the passed value as an int!
  /// Casts will stop at the first valid attempt and apply the relevant constraints as defined in the constructor.
  /// </summary>
  /// <typeparam name="Type1">The 1st possible value type of this Field.</typeparam>
  public class Field<Type1> : Field
  {
    /// <summary>
    /// The constraints whose functions will be executed on the value of the Field
    /// corresponding to <see cref="Field.FieldName"/> if it can be cast to
    /// <typeparamref name="Type1"/>, after the cast is applied.
    /// </summary>
    public List<Constraint<Type1>> ConstraintsIfType1 { get; protected set; } = new List<Constraint<Type1>>();
    /// <summary>
    /// The constraints whose functions will be executed on the value of the Field
    /// corresponding to <see cref="Field.FieldName"/> if it can be cast to
    /// <typeparamref name="Type1"/>, with the value cast to string rather than
    /// <typeparamref name="Type1"/>.
    /// </summary>
    public List<Constraint<Type1>> FormatConstraintsIfType1 { get; protected set; } = new List<Constraint<Type1>>();

    #region Constructors

    /// <summary>
    /// A <see cref="Field"/> represents a value that is expected to exist in a collection processed by a <see cref="Schema"/> object.
    /// All passed types must be unique.
    /// WARNING: Casts will be attempted IN ORDER. For example,
    /// Field{string, int} will NEVER treat the passed Field as an int!
    /// Casts will stop at the first valid attempt and apply the relevant constraints as defined in the constructor.
    /// </summary>
    /// <exception cref="ArgumentNullException">If inputName is null, whitespace, or empty.</exception>
    /// <exception cref="ArgumentException">If all Type arguments are not unique.</exception>
    /// <param name="inputName">Name of the Field. This will be used to search the user config when validating.</param>
    /// <param name="inputDescription">String that will be shown to the user in the event of a validation error.</param>
    /// <param name="constraintsIfType1">Constraints that will be applied to the Field's value if it can be cast to <typeparamref name="Type1"/>.</param>
    /// <param name="required">If true, not detecting this <see cref="Field"/> when applying a Schema is a <see cref="Severity.Fatal"/> error.
    /// If false, not detecting this Field when applying a schema raises no error.</param>
    /// <param name="allowNull">If false, detecting a null or empty value is a <see cref="Severity.Fatal"/>
    /// If true, detecting a null or empty value is a <see cref="Severity.Warning"/></param>
    public Field(string inputName, string inputDescription, Constraint<Type1>[] constraintsIfType1 = null, bool required = true, bool allowNull = false)
    {
      BuildFieldCore(inputName, inputDescription, required, allowNull);
      BuildConstraints(constraintsIfType1);
    }

    /// <summary>
    /// A <see cref="Field"/> represents a Field that is expected to exist in the input collection to a <see cref="Schema"/> object.
    /// All passed types must be unique.
    /// WARNING: Casts will be attempted IN ORDER. For example,
    /// Field{string, int} will NEVER treat the passed Field as an int!
    /// Casts will stop at the first valid attempt and apply the relevant constraints as defined in the constructor.
    /// </summary>
    /// <exception cref="ArgumentNullException">If <paramref name="inputName"/> or inputDescription is null, whitespace, or empty.</exception>
    /// <exception cref="ArgumentException">If all Type arguments are not unique.</exception>
    /// <exception cref="ArgumentException">If <paramref name="inputDefaultValue"/> can't be cast to any of the <see cref="Field"/> types.</exception>
    /// <param name="inputName">Name of the Field. This will be used to search the object that is being validated.</param>
    /// <param name="inputDescription">String that will be shown to the user in the event of a validation error.</param>
    /// <param name="inputDefaultValue">Object that will be inserted into the object that is being validated if an optional Field is not provided.
    /// If provided, assumes this Field is not required.</param>
    /// <param name="constraintsIfType1">Constraints that will be applied to the Field's value if it can be cast to <typeparamref name="Type1"/>.</param>
    /// <param name="allowNull">If false, detecting a null or empty value is a <see cref="Severity.Fatal"/>
    /// If true, detecting a null or empty value is a <see cref="Severity.Warning"/></param>
    public Field(string inputName, string inputDescription, object inputDefaultValue, Constraint<Type1>[] constraintsIfType1 = null, bool allowNull = false)
    {
      BuildFieldCore(inputName, inputDescription, false, allowNull);
      DefaultValue = inputDefaultValue;
      if (!CheckDefaultValue())
      {
        throw new ArgumentException($"Passed DefaultValue of Field {FieldName} cannot be cast to any of: {GetType().GetGenericArguments().Join(", ")}");
      }
      BuildConstraints(constraintsIfType1);
    }

    /// <summary>
    /// Internal constraint constructor. Ensures that all types are unique and assigns the constraint arrays to the appropriate fields.
    /// </summary>
    /// <param name="constraintsIfType1">Constraints that will be applied to the Field's value if it can be cast to <typeparamref name="Type1"/>.</param>
    protected void BuildConstraints(Constraint<Type1>[] constraintsIfType1 = null)
    {
      Type[] typeArray = GetType().GetGenericArguments();
      if (typeArray.Distinct().Count() != typeArray.Length)
      {
        throw new ArgumentException($"Field {FieldName} contains duplicate Type arguments: {string.Join(", ", typeArray.Select(x => x.Name))}");
      }
      JsonConstraint.Add(GetConstraintObject(constraintsIfType1));
      ConstraintsIfType1 = constraintsIfType1.Exists() ? constraintsIfType1.Where(x => x.ConstraintType == ConstraintType.Standard).ToList() : new List<Constraint<Type1>>();
      FormatConstraintsIfType1 = constraintsIfType1.Exists() ? constraintsIfType1.Where(x => x.ConstraintType == ConstraintType.Format).ToList() : new List<Constraint<Type1>>();
    }

    #endregion

    /// <summary>
    /// Returns a new <see cref="Field"/> with an additional type and new constraints added. Used primarily during deserialization.
    /// </summary>
    /// <exception cref="ArgumentException">If this <see cref="Field"/> already has <typeparamref name="TNewType"/></exception>
    /// <typeparam name="TNewType">New possible type to add to the Field.</typeparam>
    /// <param name="newConstraints">Constraints to apply if cast to the new type is successful.</param>
    /// <returns>New <see cref="Field{Type1,TNewType}"/></returns>
    public override Field AddNewType<TNewType>(Constraint<TNewType>[] newConstraints = null)
    {
      return GetType().GetGenericArguments().Contains(typeof(TNewType))
        ? throw new ArgumentException($"Field {FieldName} already has type {typeof(TNewType).Name}.")
        : DefaultValue.Exists()
        ? new Field<Type1, TNewType>(FieldName, Description, DefaultValue, ConstraintsIfType1.ToArray(), newConstraints, AllowNull)
        : new Field<Type1, TNewType>(FieldName, Description, ConstraintsIfType1.ToArray(), newConstraints, Required, AllowNull);
    }

    /// <summary>
    /// Extracts a Field named <see cref="Field.FieldName"/> from
    /// <paramref name="collection"/> using <see cref="ISchemaTranslator{TCollectionType}.TryCastValue{TCastType}(TCollectionType, string, out TCastType)"/>.
    /// If at least one cast is successful, this function executes the
    /// <see cref="Constraint{TValueType}.Function"/> of each
    /// <see cref="Constraint{TValueType}"/> of the successful cast type on the
    /// cast value.
    /// </summary>
    /// <param name="collection">Collection from which a Field will be extracted.</param>
    /// <param name="translator"><see cref="ISchemaTranslator{TCollectionType}"/> corresponding to the type of <paramref name="collection"/>.</param>
    /// <returns>Bool indicating whether any fatal errors were found during validation.</returns>
    public override bool Validate<TCollectionType>(TCollectionType collection, ISchemaTranslator<TCollectionType> translator)
    {
      base.Validate(collection, translator);
      if (translator.TryCastValue(collection, FieldName, out Type1 newValue1))
      {
        InternalValidate(newValue1, ConstraintsIfType1);
        if (FormatConstraintsIfType1.Count > 0)
        {
          translator.TryCastValue(collection, FieldName, out string stringValue);
          InternalValidateFormat(stringValue, FormatConstraintsIfType1);
        }
      }
      else
      {
        ErrorList.Add(new SchemaError($"Field {FieldName} with value {translator.CollectionValueToString(collection, FieldName)} is an incorrect type. Expected one of: {typeof(Type1).Name} ({translator.GetEquivalentType(typeof(Type1).Name)})", Severity.Fatal));
      }
      return !ErrorList.AnyFatal();
    }
  }

  /// <summary>
  /// A <see cref="Field"/> represents a value that is expected to exist in a collection processed by a <see cref="Schema"/> object.
  /// All passed types must be unique.
  /// WARNING: Casts will be attempted IN ORDER. For example,
  /// Field{string, int} will NEVER treat the passed value as an int!
  /// Casts will stop at the first valid attempt and apply the relevant constraints as defined in the constructor.
  /// </summary>
  /// <typeparam name="Type1">The 1st possible value type of this Field.</typeparam>
  /// <typeparam name="Type2">The 2nd possible value type of this Field.</typeparam>
  public class Field<Type1, Type2> : Field
  {
    /// <summary>
    /// The constraints whose functions will be executed on the value of the Field
    /// corresponding to <see cref="Field.FieldName"/> if it can be cast to
    /// <typeparamref name="Type1"/>, after the cast is applied.
    /// </summary>
    public List<Constraint<Type1>> ConstraintsIfType1 { get; protected set; } = new List<Constraint<Type1>>();
    /// <summary>
    /// The constraints whose functions will be executed on the value of the Field
    /// corresponding to <see cref="Field.FieldName"/> if it can be cast to
    /// <typeparamref name="Type1"/>, with the value cast to string rather than
    /// <typeparamref name="Type1"/>.
    /// </summary>
    public List<Constraint<Type1>> FormatConstraintsIfType1 { get; protected set; } = new List<Constraint<Type1>>();
    /// <summary>
    /// The constraints whose functions will be executed on the value of the Field
    /// corresponding to <see cref="Field.FieldName"/> if it can be cast to
    /// <typeparamref name="Type2"/>, after the cast is applied.
    /// </summary>
    public List<Constraint<Type2>> ConstraintsIfType2 { get; protected set; } = new List<Constraint<Type2>>();
    /// <summary>
    /// The constraints whose functions will be executed on the value of the Field
    /// corresponding to <see cref="Field.FieldName"/> if it can be cast to
    /// <typeparamref name="Type2"/>, with the value cast to string rather than
    /// <typeparamref name="Type2"/>.
    /// </summary>
    public List<Constraint<Type2>> FormatConstraintsIfType2 { get; protected set; } = new List<Constraint<Type2>>();

    #region Constructors

    /// <summary>
    /// A <see cref="Field"/> represents a value that is expected to exist in a collection processed by a <see cref="Schema"/> object.
    /// All passed types must be unique.
    /// WARNING: Casts will be attempted IN ORDER. For example,
    /// Field{string, int} will NEVER treat the passed Field as an int!
    /// Casts will stop at the first valid attempt and apply the relevant constraints as defined in the constructor.
    /// </summary>
    /// <exception cref="ArgumentNullException">If inputName is null, whitespace, or empty.</exception>
    /// <exception cref="ArgumentException">If all Type arguments are not unique.</exception>
    /// <param name="inputName">Name of the Field. This will be used to search the user config when validating.</param>
    /// <param name="inputDescription">String that will be shown to the user in the event of a validation error.</param>
    /// <param name="constraintsIfType1">Constraints that will be applied to the Field's value if it can be cast to <typeparamref name="Type1"/>.</param>
    /// <param name="constraintsIfType2">Constraints that will be applied to the Field's value if it can be cast to <typeparamref name="Type2"/>.</param>
    /// <param name="required">If true, not detecting this <see cref="Field"/> when applying a Schema is a <see cref="Severity.Fatal"/> error.
    /// If false, not detecting this Field when applying a schema raises no error.</param>
    /// <param name="allowNull">If false, detecting a null or empty value is a <see cref="Severity.Fatal"/>
    /// If true, detecting a null or empty value is a <see cref="Severity.Warning"/></param>
    public Field(string inputName, string inputDescription, Constraint<Type1>[] constraintsIfType1 = null, Constraint<Type2>[] constraintsIfType2 = null, bool required = true, bool allowNull = false)
    {
      BuildFieldCore(inputName, inputDescription, required, allowNull);
      BuildConstraints(constraintsIfType1, constraintsIfType2);
    }

    /// <summary>
    /// A <see cref="Field"/> represents a Field that is expected to exist in the input collection to a <see cref="Schema"/> object.
    /// All passed types must be unique.
    /// WARNING: Casts will be attempted IN ORDER. For example,
    /// Field{string, int} will NEVER treat the passed Field as an int!
    /// Casts will stop at the first valid attempt and apply the relevant constraints as defined in the constructor.
    /// </summary>
    /// <exception cref="ArgumentNullException">If <paramref name="inputName"/> or inputDescription is null, whitespace, or empty.</exception>
    /// <exception cref="ArgumentException">If all Type arguments are not unique.</exception>
    /// <exception cref="ArgumentException">If <paramref name="inputDefaultValue"/> can't be cast to any of the <see cref="Field"/> types.</exception>
    /// <param name="inputName">Name of the Field. This will be used to search the object that is being validated.</param>
    /// <param name="inputDescription">String that will be shown to the user in the event of a validation error.</param>
    /// <param name="inputDefaultValue">Object that will be inserted into the object that is being validated if an optional Field is not provided.
    /// If provided, assumes this Field is not required.</param>
    /// <param name="constraintsIfType1">Constraints that will be applied to the Field's value if it can be cast to <typeparamref name="Type1"/>.</param>
    /// <param name="constraintsIfType2">Constraints that will be applied to the Field's value if it can be cast to <typeparamref name="Type2"/>.</param>
    /// <param name="allowNull">If false, detecting a null or empty value is a <see cref="Severity.Fatal"/>
    /// If true, detecting a null or empty value is a <see cref="Severity.Warning"/></param>
    public Field(string inputName, string inputDescription, object inputDefaultValue, Constraint<Type1>[] constraintsIfType1 = null, Constraint<Type2>[] constraintsIfType2 = null, bool allowNull = false)
    {
      BuildFieldCore(inputName, inputDescription, false, allowNull);
      DefaultValue = inputDefaultValue;
      if (!CheckDefaultValue())
      {
        throw new ArgumentException($"Passed DefaultValue of Field {FieldName} cannot be cast to any of: {GetType().GetGenericArguments().Join(", ")}");
      }
      BuildConstraints(constraintsIfType1, constraintsIfType2);
    }

    /// <summary>
    /// Internal constraint constructor. Ensures that all types are unique and assigns the constraint arrays to the appropriate fields.
    /// </summary>
    /// <param name="constraintsIfType1">Constraints that will be applied to the Field's value if it can be cast to <typeparamref name="Type1"/>.</param>
    /// <param name="constraintsIfType2">Constraints that will be applied to the Field's value if it can be cast to <typeparamref name="Type2"/>.</param>
    protected void BuildConstraints(Constraint<Type1>[] constraintsIfType1 = null, Constraint<Type2>[] constraintsIfType2 = null)
    {
      Type[] typeArray = GetType().GetGenericArguments();
      if (typeArray.Distinct().Count() != typeArray.Length)
      {
        throw new ArgumentException($"Field {FieldName} contains duplicate Type arguments: {string.Join(", ", typeArray.Select(x => x.Name))}");
      }
      JsonConstraint.Add(GetConstraintObject(constraintsIfType1));
      JsonConstraint.Add(GetConstraintObject(constraintsIfType2));
      ConstraintsIfType1 = constraintsIfType1.Exists() ? constraintsIfType1.Where(x => x.ConstraintType == ConstraintType.Standard).ToList() : new List<Constraint<Type1>>();
      FormatConstraintsIfType1 = constraintsIfType1.Exists() ? constraintsIfType1.Where(x => x.ConstraintType == ConstraintType.Format).ToList() : new List<Constraint<Type1>>();
      ConstraintsIfType2 = constraintsIfType2.Exists() ? constraintsIfType2.Where(x => x.ConstraintType == ConstraintType.Standard).ToList() : new List<Constraint<Type2>>();
      FormatConstraintsIfType2 = constraintsIfType2.Exists() ? constraintsIfType2.Where(x => x.ConstraintType == ConstraintType.Format).ToList() : new List<Constraint<Type2>>();
    }

    #endregion

    /// <summary>
    /// Returns a new <see cref="Field"/> with an additional type and new constraints added. Used primarily during deserialization.
    /// </summary>
    /// <exception cref="ArgumentException">If this <see cref="Field"/> already has <typeparamref name="TNewType"/></exception>
    /// <typeparam name="TNewType">New possible type to add to the Field.</typeparam>
    /// <param name="newConstraints">Constraints to apply if cast to the new type is successful.</param>
    /// <returns>New <see cref="Field{Type1, Type2,TNewType}"/></returns>
    public override Field AddNewType<TNewType>(Constraint<TNewType>[] newConstraints = null)
    {
      return GetType().GetGenericArguments().Contains(typeof(TNewType))
        ? throw new ArgumentException($"Field {FieldName} already has type {typeof(TNewType).Name}.")
        : DefaultValue.Exists()
        ? new Field<Type1, Type2, TNewType>(FieldName, Description, DefaultValue, ConstraintsIfType1.ToArray(), ConstraintsIfType2.ToArray(), newConstraints, AllowNull)
        : new Field<Type1, Type2, TNewType>(FieldName, Description, ConstraintsIfType1.ToArray(), ConstraintsIfType2.ToArray(), newConstraints, Required, AllowNull);
    }

    /// <summary>
    /// Extracts a Field named <see cref="Field.FieldName"/> from
    /// <paramref name="collection"/> using <see cref="ISchemaTranslator{TCollectionType}.TryCastValue{TCastType}(TCollectionType, string, out TCastType)"/>.
    /// If at least one cast is successful, this function executes the
    /// <see cref="Constraint{TValueType}.Function"/> of each
    /// <see cref="Constraint{TValueType}"/> of the successful cast type on the
    /// cast value.
    /// </summary>
    /// <param name="collection">Collection from which a Field will be extracted.</param>
    /// <param name="translator"><see cref="ISchemaTranslator{TCollectionType}"/> corresponding to the type of <paramref name="collection"/>.</param>
    /// <returns>Bool indicating whether any fatal errors were found during validation.</returns>
    public override bool Validate<TCollectionType>(TCollectionType collection, ISchemaTranslator<TCollectionType> translator)
    {
      base.Validate(collection, translator);
      if (translator.TryCastValue(collection, FieldName, out Type1 newValue1))
      {
        InternalValidate(newValue1, ConstraintsIfType1);
        if (FormatConstraintsIfType1.Count > 0)
        {
          translator.TryCastValue(collection, FieldName, out string stringValue);
          InternalValidateFormat(stringValue, FormatConstraintsIfType1);
        }
      }
      else if (translator.TryCastValue(collection, FieldName, out Type2 newValue2))
      {
        InternalValidate(newValue2, ConstraintsIfType2);
        if (FormatConstraintsIfType2.Count > 0)
        {
          translator.TryCastValue(collection, FieldName, out string stringValue);
          InternalValidateFormat(stringValue, FormatConstraintsIfType2);
        }
      }
      else
      {
        ErrorList.Add(new SchemaError($"Field {FieldName} with value {translator.CollectionValueToString(collection, FieldName)} is an incorrect type. Expected one of: {typeof(Type1).Name} ({translator.GetEquivalentType(typeof(Type1).Name)}), {typeof(Type2).Name} ({translator.GetEquivalentType(typeof(Type2).Name)})", Severity.Fatal));
      }
      return !ErrorList.AnyFatal();
    }
  }

  /// <summary>
  /// A <see cref="Field"/> represents a value that is expected to exist in a collection processed by a <see cref="Schema"/> object.
  /// All passed types must be unique.
  /// WARNING: Casts will be attempted IN ORDER. For example,
  /// Field{string, int} will NEVER treat the passed value as an int!
  /// Casts will stop at the first valid attempt and apply the relevant constraints as defined in the constructor.
  /// </summary>
  /// <typeparam name="Type1">The 1st possible value type of this Field.</typeparam>
  /// <typeparam name="Type2">The 2nd possible value type of this Field.</typeparam>
  /// <typeparam name="Type3">The 3rd possible value type of this Field.</typeparam>
  public class Field<Type1, Type2, Type3> : Field
  {
    /// <summary>
    /// The constraints whose functions will be executed on the value of the Field
    /// corresponding to <see cref="Field.FieldName"/> if it can be cast to
    /// <typeparamref name="Type1"/>, after the cast is applied.
    /// </summary>
    public List<Constraint<Type1>> ConstraintsIfType1 { get; protected set; } = new List<Constraint<Type1>>();
    /// <summary>
    /// The constraints whose functions will be executed on the value of the Field
    /// corresponding to <see cref="Field.FieldName"/> if it can be cast to
    /// <typeparamref name="Type1"/>, with the value cast to string rather than
    /// <typeparamref name="Type1"/>.
    /// </summary>
    public List<Constraint<Type1>> FormatConstraintsIfType1 { get; protected set; } = new List<Constraint<Type1>>();
    /// <summary>
    /// The constraints whose functions will be executed on the value of the Field
    /// corresponding to <see cref="Field.FieldName"/> if it can be cast to
    /// <typeparamref name="Type2"/>, after the cast is applied.
    /// </summary>
    public List<Constraint<Type2>> ConstraintsIfType2 { get; protected set; } = new List<Constraint<Type2>>();
    /// <summary>
    /// The constraints whose functions will be executed on the value of the Field
    /// corresponding to <see cref="Field.FieldName"/> if it can be cast to
    /// <typeparamref name="Type2"/>, with the value cast to string rather than
    /// <typeparamref name="Type2"/>.
    /// </summary>
    public List<Constraint<Type2>> FormatConstraintsIfType2 { get; protected set; } = new List<Constraint<Type2>>();
    /// <summary>
    /// The constraints whose functions will be executed on the value of the Field
    /// corresponding to <see cref="Field.FieldName"/> if it can be cast to
    /// <typeparamref name="Type3"/>, after the cast is applied.
    /// </summary>
    public List<Constraint<Type3>> ConstraintsIfType3 { get; protected set; } = new List<Constraint<Type3>>();
    /// <summary>
    /// The constraints whose functions will be executed on the value of the Field
    /// corresponding to <see cref="Field.FieldName"/> if it can be cast to
    /// <typeparamref name="Type3"/>, with the value cast to string rather than
    /// <typeparamref name="Type3"/>.
    /// </summary>
    public List<Constraint<Type3>> FormatConstraintsIfType3 { get; protected set; } = new List<Constraint<Type3>>();

    #region Constructors

    /// <summary>
    /// A <see cref="Field"/> represents a value that is expected to exist in a collection processed by a <see cref="Schema"/> object.
    /// All passed types must be unique.
    /// WARNING: Casts will be attempted IN ORDER. For example,
    /// Field{string, int} will NEVER treat the passed Field as an int!
    /// Casts will stop at the first valid attempt and apply the relevant constraints as defined in the constructor.
    /// </summary>
    /// <exception cref="ArgumentNullException">If inputName is null, whitespace, or empty.</exception>
    /// <exception cref="ArgumentException">If all Type arguments are not unique.</exception>
    /// <param name="inputName">Name of the Field. This will be used to search the user config when validating.</param>
    /// <param name="inputDescription">String that will be shown to the user in the event of a validation error.</param>
    /// <param name="constraintsIfType1">Constraints that will be applied to the Field's value if it can be cast to <typeparamref name="Type1"/>.</param>
    /// <param name="constraintsIfType2">Constraints that will be applied to the Field's value if it can be cast to <typeparamref name="Type2"/>.</param>
    /// <param name="constraintsIfType3">Constraints that will be applied to the Field's value if it can be cast to <typeparamref name="Type3"/>.</param>
    /// <param name="required">If true, not detecting this <see cref="Field"/> when applying a Schema is a <see cref="Severity.Fatal"/> error.
    /// If false, not detecting this Field when applying a schema raises no error.</param>
    /// <param name="allowNull">If false, detecting a null or empty value is a <see cref="Severity.Fatal"/>
    /// If true, detecting a null or empty value is a <see cref="Severity.Warning"/></param>
    public Field(string inputName, string inputDescription, Constraint<Type1>[] constraintsIfType1 = null, Constraint<Type2>[] constraintsIfType2 = null, Constraint<Type3>[] constraintsIfType3 = null, bool required = true, bool allowNull = false)
    {
      BuildFieldCore(inputName, inputDescription, required, allowNull);
      BuildConstraints(constraintsIfType1, constraintsIfType2, constraintsIfType3);
    }

    /// <summary>
    /// A <see cref="Field"/> represents a Field that is expected to exist in the input collection to a <see cref="Schema"/> object.
    /// All passed types must be unique.
    /// WARNING: Casts will be attempted IN ORDER. For example,
    /// Field{string, int} will NEVER treat the passed Field as an int!
    /// Casts will stop at the first valid attempt and apply the relevant constraints as defined in the constructor.
    /// </summary>
    /// <exception cref="ArgumentNullException">If <paramref name="inputName"/> or inputDescription is null, whitespace, or empty.</exception>
    /// <exception cref="ArgumentException">If all Type arguments are not unique.</exception>
    /// <exception cref="ArgumentException">If <paramref name="inputDefaultValue"/> can't be cast to any of the <see cref="Field"/> types.</exception>
    /// <param name="inputName">Name of the Field. This will be used to search the object that is being validated.</param>
    /// <param name="inputDescription">String that will be shown to the user in the event of a validation error.</param>
    /// <param name="inputDefaultValue">Object that will be inserted into the object that is being validated if an optional Field is not provided.
    /// If provided, assumes this Field is not required.</param>
    /// <param name="constraintsIfType1">Constraints that will be applied to the Field's value if it can be cast to <typeparamref name="Type1"/>.</param>
    /// <param name="constraintsIfType2">Constraints that will be applied to the Field's value if it can be cast to <typeparamref name="Type2"/>.</param>
    /// <param name="constraintsIfType3">Constraints that will be applied to the Field's value if it can be cast to <typeparamref name="Type3"/>.</param>
    /// <param name="allowNull">If false, detecting a null or empty value is a <see cref="Severity.Fatal"/>
    /// If true, detecting a null or empty value is a <see cref="Severity.Warning"/></param>
    public Field(string inputName, string inputDescription, object inputDefaultValue, Constraint<Type1>[] constraintsIfType1 = null, Constraint<Type2>[] constraintsIfType2 = null, Constraint<Type3>[] constraintsIfType3 = null, bool allowNull = false)
    {
      BuildFieldCore(inputName, inputDescription, false, allowNull);
      DefaultValue = inputDefaultValue;
      if (!CheckDefaultValue())
      {
        throw new ArgumentException($"Passed DefaultValue of Field {FieldName} cannot be cast to any of: {GetType().GetGenericArguments().Join(", ")}");
      }
      BuildConstraints(constraintsIfType1, constraintsIfType2, constraintsIfType3);
    }

    /// <summary>
    /// Internal constraint constructor. Ensures that all types are unique and assigns the constraint arrays to the appropriate fields.
    /// </summary>
    /// <param name="constraintsIfType1">Constraints that will be applied to the Field's value if it can be cast to <typeparamref name="Type1"/>.</param>
    /// <param name="constraintsIfType2">Constraints that will be applied to the Field's value if it can be cast to <typeparamref name="Type2"/>.</param>
    /// <param name="constraintsIfType3">Constraints that will be applied to the Field's value if it can be cast to <typeparamref name="Type3"/>.</param>
    protected void BuildConstraints(Constraint<Type1>[] constraintsIfType1 = null, Constraint<Type2>[] constraintsIfType2 = null, Constraint<Type3>[] constraintsIfType3 = null)
    {
      Type[] typeArray = GetType().GetGenericArguments();
      if (typeArray.Distinct().Count() != typeArray.Length)
      {
        throw new ArgumentException($"Field {FieldName} contains duplicate Type arguments: {string.Join(", ", typeArray.Select(x => x.Name))}");
      }
      JsonConstraint.Add(GetConstraintObject(constraintsIfType1));
      JsonConstraint.Add(GetConstraintObject(constraintsIfType2));
      JsonConstraint.Add(GetConstraintObject(constraintsIfType3));
      ConstraintsIfType1 = constraintsIfType1.Exists() ? constraintsIfType1.Where(x => x.ConstraintType == ConstraintType.Standard).ToList() : new List<Constraint<Type1>>();
      FormatConstraintsIfType1 = constraintsIfType1.Exists() ? constraintsIfType1.Where(x => x.ConstraintType == ConstraintType.Format).ToList() : new List<Constraint<Type1>>();
      ConstraintsIfType2 = constraintsIfType2.Exists() ? constraintsIfType2.Where(x => x.ConstraintType == ConstraintType.Standard).ToList() : new List<Constraint<Type2>>();
      FormatConstraintsIfType2 = constraintsIfType2.Exists() ? constraintsIfType2.Where(x => x.ConstraintType == ConstraintType.Format).ToList() : new List<Constraint<Type2>>();
      ConstraintsIfType3 = constraintsIfType3.Exists() ? constraintsIfType3.Where(x => x.ConstraintType == ConstraintType.Standard).ToList() : new List<Constraint<Type3>>();
      FormatConstraintsIfType3 = constraintsIfType3.Exists() ? constraintsIfType3.Where(x => x.ConstraintType == ConstraintType.Format).ToList() : new List<Constraint<Type3>>();
    }

    #endregion

    /// <summary>
    /// Returns a new <see cref="Field"/> with an additional type and new constraints added. Used primarily during deserialization.
    /// </summary>
    /// <exception cref="ArgumentException">If this <see cref="Field"/> already has <typeparamref name="TNewType"/></exception>
    /// <typeparam name="TNewType">New possible type to add to the Field.</typeparam>
    /// <param name="newConstraints">Constraints to apply if cast to the new type is successful.</param>
    /// <returns>Nothing but a NotImplemented Exception. And disappointment.</returns>
    public override Field AddNewType<TNewType>(Constraint<TNewType>[] newConstraints = null) => throw new NotImplementedException("A Field cannot have more than three types.");

    /// <summary>
    /// Extracts a Field named <see cref="Field.FieldName"/> from
    /// <paramref name="collection"/> using <see cref="ISchemaTranslator{TCollectionType}.TryCastValue{TCastType}(TCollectionType, string, out TCastType)"/>.
    /// If at least one cast is successful, this function executes the
    /// <see cref="Constraint{TValueType}.Function"/> of each
    /// <see cref="Constraint{TValueType}"/> of the successful cast type on the
    /// cast value.
    /// </summary>
    /// <param name="collection">Collection from which a Field will be extracted.</param>
    /// <param name="translator"><see cref="ISchemaTranslator{TCollectionType}"/> corresponding to the type of <paramref name="collection"/>.</param>
    /// <returns>Bool indicating whether any fatal errors were found during validation.</returns>
    public override bool Validate<TCollectionType>(TCollectionType collection, ISchemaTranslator<TCollectionType> translator)
    {
      base.Validate(collection, translator);
      if (translator.TryCastValue(collection, FieldName, out Type1 newValue1))
      {
        InternalValidate(newValue1, ConstraintsIfType1);
        if (FormatConstraintsIfType1.Count > 0)
        {
          translator.TryCastValue(collection, FieldName, out string stringValue);
          InternalValidateFormat(stringValue, FormatConstraintsIfType1);
        }
      }
      else if (translator.TryCastValue(collection, FieldName, out Type2 newValue2))
      {
        InternalValidate(newValue2, ConstraintsIfType2);
        if (FormatConstraintsIfType2.Count > 0)
        {
          translator.TryCastValue(collection, FieldName, out string stringValue);
          InternalValidateFormat(stringValue, FormatConstraintsIfType2);
        }
      }
      else if (translator.TryCastValue(collection, FieldName, out Type3 newValue3))
      {
        InternalValidate(newValue3, ConstraintsIfType3);
        if (FormatConstraintsIfType3.Count > 0)
        {
          translator.TryCastValue(collection, FieldName, out string stringValue);
          InternalValidateFormat(stringValue, FormatConstraintsIfType3);
        }
      }
      else
      {
        ErrorList.Add(new SchemaError($"Field {FieldName} with value {translator.CollectionValueToString(collection, FieldName)} is an incorrect type. Expected one of: {typeof(Type1).Name} ({translator.GetEquivalentType(typeof(Type1).Name)}), {typeof(Type2).Name} ({translator.GetEquivalentType(typeof(Type2).Name)}), {typeof(Type3).Name} ({translator.GetEquivalentType(typeof(Type3).Name)})", Severity.Fatal));
      }
      return !ErrorList.AnyFatal();
    }
  }
}
