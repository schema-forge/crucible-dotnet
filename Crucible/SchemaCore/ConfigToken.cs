using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using SchemaForge.Crucible.Extensions;
using Newtonsoft.Json.Linq;

namespace SchemaForge.Crucible
{
  public abstract class ConfigToken
  {
    /// <summary>
    /// Name of the token; corresponds to a token present in the JObject that will be validated.
    /// </summary>
    public string TokenName { get; protected set; }
    /// <summary>
    /// String that will be added to the ErrorList of a Schema object as ErrorSeverity.Info when a validation error occurs for this token.
    /// </summary>
    public string HelpString { get; protected set; }
    /// <summary>
    /// Contains all the errors generated by validation functions.
    /// </summary>
    public List<Error> ErrorList { get; protected set; } = new();
    public JArray JsonConstraint { get; protected set; } = new();
    /// <summary>
    /// Indicates whether or not this token is required.
    /// </summary>
    public bool Required { get; protected set; }

    public abstract bool Validate<TCollectionType, TValueType>(TCollectionType collection, ISchemaTranslator<TCollectionType, TValueType> translator);

    #region Overrides

    public override string ToString() => TokenName;

    /// <summary>
    /// All equality operators compare the TokenName of two ConfigTokens to determine equality.
    /// </summary>
    /// <param name="obj">The other object to compare.</param>
    /// <returns>Bool indicating if two ConfigTokens have the same name.</returns>
    public override bool Equals(object obj) => this.Equals(obj as ConfigToken);

    /// <summary>
    /// All equality operators compare the TokenName of two ConfigTokens to determine equality.
    /// </summary>
    /// <param name="other">The other token to compare.</param>
    /// <returns>Bool indicating if two ConfigTokens have the same name.</returns>
    public bool Equals(ConfigToken other)
    {
      if (!other.Exists())
      {
        return false;
      }
      if (this.TokenName == other.TokenName)
      {
        return true;
      }
      else
      {
        return false;
      }
    }

    /// <summary>
    /// Sets the HashCode of a ConfigToken to the HashCode of its TokenName.
    /// </summary>
    /// <returns>HashCode of TokenName string.</returns>
    public override int GetHashCode() => TokenName.GetHashCode();

    #endregion

    #region Helper Methods

    /// <summary>
    /// Gets JObject representation of the type and all other constraints.
    /// </summary>
    /// <typeparam name="TValueType">Type of all constraints.</typeparam>
    /// <param name="constraints">Array of constraints that have been applied by <see cref="ApplyConstraints{TValueType}"/>.</param>
    /// <returns>JObject representation of the constraints applied to the token.</returns>
    protected static JObject GetConstraintObject<TValueType>(Constraint<TValueType>[] constraints)
    {
      JObject constraintObject = new();
      try
      {
        if (typeof(TValueType).ToString().Contains("Nullable"))
        {
          constraintObject.Add("Type", ShippingAndReceiving.TypeMap(typeof(TValueType).GenericTypeArguments[0].Name));
        }
        else
        {
          constraintObject.Add("Type", ShippingAndReceiving.TypeMap(typeof(TValueType).Name));
        }
      }
      catch
      {
        throw new ArgumentException($"Attempted to pass unsupported type {typeof(TValueType).Name}\nSupported types: {ShippingAndReceiving.GetSupportedTypes().Join(", ")}\nIf needed, use AddSupportedType to add a new type to the recognized types. This will enable SchemaForge to recognize this token type for your project.");
      }
      if (constraints.Exists())
      {
        foreach (Constraint<TValueType> constraint in constraints)
        {
          constraintObject.Add(constraint.Property);
        }
      }
      return constraintObject;
    }

    protected void BuildConfigTokenCore(string inputName, string inputHelpString, bool required)
    {
      if (inputName.IsNullOrEmpty())
      {
        throw new ArgumentNullException(nameof(inputName));
      }
      if (inputHelpString.IsNullOrEmpty())
      {
        throw new ArgumentNullException(nameof(inputHelpString));
      }
      Required = required;
      TokenName = inputName;
      HelpString = inputHelpString;
    }

    protected bool InternalValidate<TValueType>((bool, TValueType) castResult, List<Constraint<TValueType>> constraints)
    {
      if (!castResult.Item1)
      {
        return false;
      }
      else
      {
        foreach (Constraint<TValueType> constraint in constraints)
        {
          ErrorList.AddRange(constraint.Function(castResult.Item2, TokenName));
        }
        return true;
      }
    }

    #endregion
  }
  /// <summary>
  /// A ConfigToken represents a value that is expected to exist in a collection processed by a Schema object.
  /// </summary>
  /// <typeparam name="Type1">The value type that the value of this token will be cast to.</typeparam>
  public class ConfigToken<Type1> : ConfigToken
  {
    /// <summary>
    /// If set and the token is optional, then if the user does not include this token in their configuration file, the default value will be inserted with TokenName as the property name.
    /// </summary>
    public Type1 DefaultValue { get; protected set; }
    public List<Constraint<Type1>> ConstraintsIfType1 { get; protected set; } = new();

    #region Constructors

    /// <summary>
    /// A ConfigToken represents a token that is expected to exist in the input JObject to a Schema object.
    /// </summary>
    /// <exception cref="ArgumentNullException">If inputName or inputHelpString is null, whitespace, or empty.</exception>
    /// <param name="inputName">Name of the token. This will be used to search the user config when validating.</param>
    /// <param name="inputHelpString">String that will be shown to the user in the event of a validation error.</param>
    /// <param name="constraintsIfType1">Constraints that will be applied to the token's value if it can be cast to Type1.</param>
    public ConfigToken(string inputName, string inputHelpString, params Constraint<Type1>[] constraintsIfType1)
    {
      BuildConfigTokenCore(inputName, inputHelpString, true);
      BuildConstraints(constraintsIfType1);
    }

    /// <summary>
    /// A ConfigToken represents a token that is expected to exist in the input JObject to a Schema object.
    /// </summary>
    /// <exception cref="ArgumentNullException">If inputName or inputHelpString is null, whitespace, or empty.</exception>
    /// <param name="inputName">Name of the token. This will be used to search the user config when validating.</param>
    /// <param name="inputHelpString">String that will be shown to the user in the event of a validation error.</param>
    /// <param name="constraintsIfType1">Constraints that will be applied to the token's value if it can be cast to Type1.</param>
    public ConfigToken(string inputName, string inputHelpString, bool required, params Constraint<Type1>[] constraintsIfType1)
    {
      BuildConfigTokenCore(inputName, inputHelpString, required);
      BuildConstraints(constraintsIfType1);
    }

    /// <summary>
    /// A ConfigToken represents a token that is expected to exist in the input JObject to a Schema object.
    /// </summary>
    /// <exception cref="ArgumentNullException">If inputName, inputDefaultValue, or inputHelpString is null, whitespace, or empty.</exception>
    /// <param name="inputName">Name of the token. This will be used to search the user config when validating.</param>
    /// <param name="inputHelpString">String that will be shown to the user in the event of a validation error.</param>
    /// <param name="inputDefaultValue">String that will be inserted into the user config if an optional token is not provided.</param>
    /// <param name="constraintsIfType1">Constraints that will be applied to the token's value if it can be cast to Type1.</param>
    public ConfigToken(string inputName, string inputHelpString, Type1 inputDefaultValue, params Constraint<Type1>[] constraintsIfType1)
    {
      BuildConfigTokenCore(inputName, inputHelpString, false);
      DefaultValue = inputDefaultValue;
      BuildConstraints(constraintsIfType1);
    }

    protected void BuildConstraints(Constraint<Type1>[] constraintsIfType1)
    {
      JsonConstraint.Add(GetConstraintObject(constraintsIfType1));
      ConstraintsIfType1 = constraintsIfType1.ToList();
    }

    #endregion

    /// <summary>
    /// Executes the ConfigToken's ValidationFunction on the passed JToken.
    /// </summary>
    /// <param name="tokenValue">Token value to validate.</param>
    /// <returns>Bool indicating whether any fatal errors were found during validation.</returns>
    public override bool Validate<TCollectionType,TValueType>(TCollectionType collection, ISchemaTranslator<TCollectionType,TValueType> translator)
    {
      if(!InternalValidate(translator.TryCastToken<Type1>(collection,TokenName),ConstraintsIfType1))
      {
        ErrorList.Add(new Error($"Token {TokenName} with value {translator.CollectionValueToString(collection,TokenName)} is an incorrect type. Expected value type: {typeof(Type1).Name}"));
      }
      return !ErrorList.AnyFatal();
    }
  }

  /// <summary>
  /// A ConfigToken represents a value that is expected to exist in a collection processed by a Schema object.
  /// WARNING: Casts will be attempted IN ORDER. For example,
  /// ConfigToken{string, int} will NEVER treat the passed token as an int!
  /// Casts will stop at the first valid attempt and apply the relevant constraints as defined in the constructor.
  /// </summary>
  /// <typeparam name="Type1">The first possible value type of this token.</typeparam>
  /// <typeparam name="Type2">The second possible value type of this token.</typeparam>
  public class ConfigToken<Type1, Type2> : ConfigToken
  {
    /// <summary>
    /// If set and the token is optional, then if the user does not include this token in their configuration file, the default value will be inserted with TokenName as the property name.
    /// </summary>
    public Type1 DefaultValue { get; protected set; }
    public List<Constraint<Type1>> ConstraintsIfType1 { get; protected set; } = new();
    public List<Constraint<Type2>> ConstraintsIfType2 { get; protected set; } = new();

    #region Constructors

    /// <summary>
    /// A ConfigToken represents a token that is expected to exist in the input JObject to a Schema object.
    /// </summary>
    /// <exception cref="ArgumentNullException">If inputName or inputHelpString is null, whitespace, or empty.</exception>
    /// <param name="inputName">Name of the token. This will be used to search the user config when validating.</param>
    /// <param name="inputHelpString">String that will be shown to the user in the event of a validation error.</param>
    /// <param name="inputValidationFunction">Function that will be executed on the corresponding value in the input config. Ideally created by ApplyConstraints().</param>
    public ConfigToken(string inputName, string inputHelpString, Constraint<Type1>[] constraintsIfType1, Constraint<Type2>[] constraintsIfType2)
    {
      BuildConfigTokenCore(inputName, inputHelpString, true);
      BuildConstraints(constraintsIfType1, constraintsIfType2);
    }

    /// <summary>
    /// A ConfigToken represents a token that is expected to exist in the input JObject to a Schema object.
    /// </summary>
    /// <exception cref="ArgumentNullException">If inputName or inputHelpString is null, whitespace, or empty.</exception>
    /// <param name="inputName">Name of the token. This will be used to search the user config when validating.</param>
    /// <param name="inputHelpString">String that will be shown to the user in the event of a validation error.</param>
    /// <param name="inputValidationFunction">Function that will be executed on the corresponding value in the input config. Ideally created by ApplyConstraints().</param>
    public ConfigToken(string inputName, string inputHelpString, bool required, Constraint<Type1>[] constraintsIfType1, Constraint<Type2>[] constraintsIfType2)
    {
      BuildConfigTokenCore(inputName, inputHelpString, required);
      BuildConstraints(constraintsIfType1, constraintsIfType2);
    }

    /// <summary>
    /// A ConfigToken represents a token that is expected to exist in the input JObject to a Schema object.
    /// </summary>
    /// <exception cref="ArgumentNullException">If inputName, inputDefaultValue, or inputHelpString is null, whitespace, or empty.</exception>
    /// <param name="inputName">Name of the token. This will be used to search the user config when validating.</param>
    /// <param name="inputHelpString">String that will be shown to the user in the event of a validation error.</param>
    /// <param name="inputDefaultValue">String that will be inserted into the user config if an optional token is not provided.</param>
    /// <param name="inputValidationFunction">Function that will be executed on the corresponding value in the input config. Ideally created by ApplyConstraints().></param>
    public ConfigToken(string inputName, string inputHelpString, Type1 inputDefaultValue, Constraint<Type1>[] constraintsIfType1, Constraint<Type2>[] constraintsIfType2)
    {
      BuildConfigTokenCore(inputName, inputHelpString, false);
      DefaultValue = inputDefaultValue;
      BuildConstraints(constraintsIfType1, constraintsIfType2);
    }

    protected void BuildConstraints(Constraint<Type1>[] constraintsIfType1, Constraint<Type2>[] constraintsIfType2)
    {
      JsonConstraint.Add(GetConstraintObject(constraintsIfType1));
      JsonConstraint.Add(GetConstraintObject(constraintsIfType2));
      ConstraintsIfType1 = constraintsIfType1.ToList();
      ConstraintsIfType2 = constraintsIfType2.ToList();
    }

    #endregion

    /// <summary>
    /// Executes the ConfigToken's ValidationFunction on the passed JToken.
    /// </summary>
    /// <param name="tokenValue">Token value to validate.</param>
    /// <returns>Bool indicating whether any fatal errors were found during validation.</returns>
    public override bool Validate<TCollectionType, TValueType>(TCollectionType collection, ISchemaTranslator<TCollectionType, TValueType> translator)
    {
      if(!InternalValidate(translator.TryCastToken<Type1>(collection, TokenName), ConstraintsIfType1) 
        && !InternalValidate(translator.TryCastToken<Type2>(collection, TokenName), ConstraintsIfType2))
      {
        ErrorList.Add(new Error($"Token {TokenName} with value {translator.CollectionValueToString(collection, TokenName)} is an incorrect type. Expected value type: {typeof(Type1).Name} or {typeof(Type2).Name}"));
      }
      return !ErrorList.AnyFatal();
    }
  }

  /// <summary>
  /// A ConfigToken represents a value that is expected to exist in a collection processed by a Schema object.
  /// WARNING: Casts will be attempted IN ORDER. For example,
  /// ConfigToken{string, int} will NEVER treat the passed token as an int!
  /// Casts will stop at the first valid attempt and apply the relevant constraints as defined in the constructor.
  /// </summary>
  /// <typeparam name="Type1">The first possible value type of this token.</typeparam>
  /// <typeparam name="Type2">The second possible value type of this token.</typeparam>
  /// <typeparam name="Type3">The second possible value type of this token.</typeparam>
  public class ConfigToken<Type1, Type2, Type3> : ConfigToken
  {
    /// <summary>
    /// If set and the token is optional, then if the user does not include this token in their configuration file, the default value will be inserted with TokenName as the property name.
    /// </summary>
    public Type1 DefaultValue { get; protected set; }
    public List<Constraint<Type1>> ConstraintsIfType1 { get; protected set; } = new();
    public List<Constraint<Type2>> ConstraintsIfType2 { get; protected set; } = new();
    public List<Constraint<Type3>> ConstraintsIfType3 { get; protected set; } = new();

    #region Constructors

    /// <summary>
    /// A ConfigToken represents a token that is expected to exist in the input JObject to a Schema object.
    /// </summary>
    /// <exception cref="ArgumentNullException">If inputName or inputHelpString is null, whitespace, or empty.</exception>
    /// <param name="inputName">Name of the token. This will be used to search the user config when validating.</param>
    /// <param name="inputHelpString">String that will be shown to the user in the event of a validation error.</param>
    /// <param name="inputValidationFunction">Function that will be executed on the corresponding value in the input config. Ideally created by ApplyConstraints().</param>
    public ConfigToken(string inputName, string inputHelpString, Constraint<Type1>[] constraintsIfType1, Constraint<Type2>[] constraintsIfType2, Constraint<Type3>[] constraintsIfType3)
    {
      BuildConfigTokenCore(inputName, inputHelpString, true);
      BuildConstraints(constraintsIfType1, constraintsIfType2, constraintsIfType3);
    }

    /// <summary>
    /// A ConfigToken represents a token that is expected to exist in the input JObject to a Schema object.
    /// </summary>
    /// <exception cref="ArgumentNullException">If inputName or inputHelpString is null, whitespace, or empty.</exception>
    /// <param name="inputName">Name of the token. This will be used to search the user config when validating.</param>
    /// <param name="inputHelpString">String that will be shown to the user in the event of a validation error.</param>
    /// <param name="inputValidationFunction">Function that will be executed on the corresponding value in the input config. Ideally created by ApplyConstraints().</param>
    public ConfigToken(string inputName, string inputHelpString, bool required, Constraint<Type1>[] constraintsIfType1, Constraint<Type2>[] constraintsIfType2, Constraint<Type3>[] constraintsIfType3)
    {
      BuildConfigTokenCore(inputName, inputHelpString, required);
      BuildConstraints(constraintsIfType1, constraintsIfType2, constraintsIfType3);
    }

    /// <summary>
    /// A ConfigToken represents a token that is expected to exist in the input JObject to a Schema object.
    /// </summary>
    /// <exception cref="ArgumentNullException">If inputName, inputDefaultValue, or inputHelpString is null, whitespace, or empty.</exception>
    /// <param name="inputName">Name of the token. This will be used to search the user config when validating.</param>
    /// <param name="inputHelpString">String that will be shown to the user in the event of a validation error.</param>
    /// <param name="inputDefaultValue">String that will be inserted into the user config if an optional token is not provided.</param>
    /// <param name="inputValidationFunction">Function that will be executed on the corresponding value in the input config. Ideally created by ApplyConstraints().></param>
    public ConfigToken(string inputName, string inputHelpString, Type1 inputDefaultValue, Constraint<Type1>[] constraintsIfType1, Constraint<Type2>[] constraintsIfType2, Constraint<Type3>[] constraintsIfType3)
    {
      BuildConfigTokenCore(inputName, inputHelpString, false);
      DefaultValue = inputDefaultValue;
      BuildConstraints(constraintsIfType1, constraintsIfType2, constraintsIfType3);
    }

    protected void BuildConstraints(Constraint<Type1>[] constraintsIfType1, Constraint<Type2>[] constraintsIfType2, Constraint<Type3>[] constraintsIfType3)
    {
      JsonConstraint.Add(GetConstraintObject(constraintsIfType1));
      JsonConstraint.Add(GetConstraintObject(constraintsIfType2));
      ConstraintsIfType1 = constraintsIfType1.ToList();
      ConstraintsIfType2 = constraintsIfType2.ToList();
      ConstraintsIfType3 = constraintsIfType3.ToList();
    }

    #endregion

    /// <summary>
    /// Executes the ConfigToken's ValidationFunction on the passed JToken.
    /// </summary>
    /// <param name="tokenValue">Token value to validate.</param>
    /// <returns>Bool indicating whether any fatal errors were found during validation.</returns>
    public override bool Validate<TCollectionType, TValueType>(TCollectionType collection, ISchemaTranslator<TCollectionType, TValueType> translator)
    {
      if (!InternalValidate(translator.TryCastToken<Type1>(collection, TokenName), ConstraintsIfType1)
        && !InternalValidate(translator.TryCastToken<Type2>(collection, TokenName), ConstraintsIfType2)
        && !InternalValidate(translator.TryCastToken<Type3>(collection, TokenName), ConstraintsIfType3))
      {
        ErrorList.Add(new Error($"Token {TokenName} with value {translator.CollectionValueToString(collection, TokenName)} is an incorrect type. Expected value type: {typeof(Type1).Name}, {typeof(Type2).Name}, or {typeof(Type3).Name}"));
      }
      return !ErrorList.AnyFatal();
    }
  }
}
